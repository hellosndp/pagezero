<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PageZero · Dashboard</title>

  <!-- Inconsolata 1-->
  <link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@400;600;700&display=swap" rel="stylesheet">

  <!-- Tailwind CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: { mono: ['Inconsolata', 'ui-monospace', 'SFMono-Regular'] },
          colors: { pz: { dark: '#1F2933', light: '#ffffff' } }
        }
      }
    }
  </script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    :root{
      --pz-dark:#1F2933;
      --pz-light:#ffffff;
      --pz-green:#16a34a;
      --pz-yellow:#f59e0b;
      --pz-muted:rgba(31,41,51,0.06);
    }
    html,body{height:100%}
    body {
      font-family: Inconsolata, monospace;
      background: var(--pz-light);
      color: var(--pz-dark);
      margin:0;
      padding:24px;
    }
    .max-w { max-width: 1024px; margin: 0 auto; }
    .card {
      background: var(--pz-light);
      border: 1px solid rgba(31,41,51,0.06);
      border-radius: 12px;
      padding: 16px;
      box-sizing: border-box;
    }
    .muted { color: rgba(31,41,51,0.65); }
    .bignum { font-weight:700; font-size: 1.8rem; }
    .avatar-btn { width:44px;height:44px;border-radius:9999px;overflow:hidden;display:inline-block;border:1px solid rgba(31,41,51,0.08); }
    .small { font-size:0.85rem; }
    #chartWrapper { height: 40vh; min-height: 220px; }
    .bar-value-tooltip {
      position: fixed; z-index: 60; background: rgba(31,41,51,0.95); color: #fff; padding: 6px 8px; border-radius: 6px;
      font-size: 13px; pointer-events: none; transform: translate(-50%, -100%); box-shadow: 0 6px 18px rgba(0,0,0,0.12); white-space: nowrap;
    }
    .filter-btn { padding: 6px 10px; border-radius: 8px; border: 1px solid rgba(31,41,51,0.06); background: white; cursor:pointer }
    .filter-btn.active { background: rgba(31,41,51,0.92); color: white; border-color: rgba(31,41,51,0.92); }
    label.small-muted { display:block; font-size:12px; color:rgba(31,41,51,0.65); margin-bottom:6px; }
    .input-wrap { display:flex; flex-direction:column; gap:6px; }
    .legend-row { display:flex; gap:12px; align-items:center; justify-content:center; margin-top:8px; flex-wrap:wrap }
    .legend-box { width:14px; height:14px; border-radius:3px; display:inline-block; border:1px solid rgba(0,0,0,0.06) }
    .zero-box { background: white; border: 1px dashed rgba(31,41,51,0.12) }
    #shareRow { margin-top: 10px; display:flex; justify-content:center; gap:12px; align-items:center }
    #shareBtn { padding:8px 12px; border-radius:8px; border:1px solid rgba(31,41,51,0.08); background:white; cursor:pointer }
    footer.text-muted { font-size:12px; color:rgba(31,41,51,0.6); margin-top:18px; text-align:center; }
    @media (max-width:640px){
      .bignum{font-size:1.3rem}
    }
  </style>
</head>
<body>
  <div class="max-w">
    <header class="flex items-center justify-between mb-6">
      <div class="flex items-center gap-3">
        <svg width="36" height="36" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden>
          <rect x="2" y="3" width="20" height="18" rx="3" stroke="var(--pz-dark)" stroke-width="1.5" fill="none"/>
          <path d="M7 8h10" stroke="var(--pz-dark)" stroke-width="1.5" stroke-linecap="round"/>
        </svg>
        <div>
          <div style="font-size:18px;font-weight:600">PageZero</div>
          <div class="muted" style="font-size:12px">NaNoWriMo 2025</div>
        </div>
      </div>

      <div class="flex items-center gap-4">
        <div class="text-right mr-2 hidden md:block">
          <div id="headerName" style="font-weight:600">You</div>
          <div id="headerEmail" class="muted small"></div>
        </div>

        <button id="profileBtn" class="avatar-btn" title="Open profile">
          <img id="headerAvatar" src="" alt="avatar" class="w-full h-full object-cover" />
        </button>
      </div>
    </header>

    <!-- CHART AREA -->
    <section class="card mb-6">
      <div class="flex items-center justify-between mb-3">
        <div class="flex items-center gap-3">
          <button id="btnJourney" class="filter-btn">Journey</button>
          <button id="btnNov" class="filter-btn active">November</button>
          <button id="btnWeek" class="filter-btn">This week</button>
        </div>
        <button
          id="shareBtn"
          class="text-sm px-3 py-1.5 border rounded-lg bg-gray-100 text-gray-400 cursor-not-allowed"
          title="Sharing coming soon"
        >
          Share
        </button>
      </div>

      <div id="chartWrapper">
        <canvas id="mainChart"></canvas>
      </div>

      <div class="legend-row" id="legendRow"></div>
    </section>

    <!-- Insights -->
    <section class="card mb-6 grid grid-cols-1 md:grid-cols-4 gap-4 text-center">
      <div>
        <div class="muted small">Total words (period)</div>
        <div id="totalWords" class="bignum">—</div>
      </div>
      <div>
        <div class="muted small">Avg / day</div>
        <div id="avgDaily" class="bignum">—</div>
      </div>
      <div>
        <div class="muted small">Total time spent</div>
        <div id="totalTime" class="bignum">—</div>
      </div>
      <div>
        <div class="muted small">Avg time / day</div>
        <div id="avgTime" class="bignum">—</div>
      </div>
    </section>

    <!-- DAILY LOGS -->
    <section class="card mb-6">
      <div class="mb-3">
        <div style="font-weight:600">Daily logs</div>
        <div class="text-xs muted">Log date, words and minutes spent</div>
      </div>

      <div class="grid grid-cols-1 md:grid-cols-4 gap-4 items-start">
        <div class="input-wrap">
          <label class="small-muted">Date</label>
          <input id="dateField" type="date" class="p-2 border rounded w-full " />
          <div class="text-xs muted mt-1">Default: your local date</div>
        </div>

        <div class="input-wrap">
          <label class="small-muted">Word Count</label>
          <input id="todayInput" type="number" min="0" step="1" placeholder="Enter word count" class="p-2 border rounded w-full " />
        </div>

        <div class="input-wrap">
          <label class="small-muted">Duration (minutes)</label>
          <input id="timeInput" type="number" min="0" step="1" placeholder="Minutes" class="p-2 border rounded w-full " />
        </div>

        <!-- Save button + status -->
        <div class="flex flex-col items-start md:items-end gap-1">
          <label class="small-muted invisible md:visible">&nbsp;</label>
          <button id="saveTodayBtn" class="px-4 py-2 rounded border">
            Save
          </button>
          <div id="saveMsg" class="text-xs muted mt-1"></div>
        </div>
      </div>
    </section>

    <footer class="text-muted">Built for PageZero — minimal, clean.</footer>
  </div>

  <!-- PROFILE MODAL (kept for future) -->
  <div id="profileModal" class="fixed inset-0 z-50 hidden items-center justify-center bg-black/40">
    <div class="bg-white p-6 rounded-lg w-full max-w-md">
      <div class="flex items-center justify-between mb-4">
        <h3 style="font-weight:600">Profile</h3>
        <button id="closeProfile" class="text-sm muted">Close</button>
      </div>

      <div class="flex items-center gap-4 mb-4">
        <div class="w-20 h-20 rounded-full overflow-hidden border" id="profileAvatarWrap">
          <img id="profileAvatar" src="" alt="avatar" class="w-full h-full object-cover" />
        </div>
        <div class="flex-1">
          <div class="text-xs muted">Display name</div>
          <input id="profileName" class="w-full p-2 border rounded mt-1" />
          <div class="text-xs muted mt-3">Upload avatar</div>
          <input type="file" id="avatarFile" accept="image/*" class="mt-1" />
        </div>
      </div>

      <div id="profileMsg" class="small muted mb-2"></div>
      <div class="flex justify-end gap-2">
        <button id="saveProfileBtn" class="px-4 py-2 rounded border">Save</button>
      </div>
    </div>
  </div>

  <!-- SCRIPT -->
  <script type="module">
    import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm'

    // ---------- CONFIG ----------
    const SUPABASE_URL = 'https://fagmvslaoyiqonyphbsh.supabase.co'
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZhZ212c2xhb3lpcW9ueXBoYnNoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjMyMjQ2NDAsImV4cCI6MjA3ODgwMDY0MH0.5abTldTV0IoeVqQ8RzaJjFM1z25coWxPbKhqhPJPsUI'
    const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY)
    // -----------------------------

    // constants/colors
    let TARGET_WORDS = 1667
    const COLOR_ZERO = '#ffffff'
    const COLOR_NORMAL = 'rgba(31,41,51,0.92)'
    const COLOR_OVER = '#16a34a'
    const COLOR_HIGHEST = '#f59e0b'

    // DOM refs
    const mainCanvas = document.getElementById('mainChart')
    const totalWordsEl = document.getElementById('totalWords')
    const avgDailyEl = document.getElementById('avgDaily')
    const totalTimeEl = document.getElementById('totalTime')
    const avgTimeEl = document.getElementById('avgTime')
    const dateField = document.getElementById('dateField')
    const todayInput = document.getElementById('todayInput')
    const timeInput = document.getElementById('timeInput')
    const saveTodayBtn = document.getElementById('saveTodayBtn')
    const saveMsg = document.getElementById('saveMsg')
    const btnNov = document.getElementById('btnNov')
    const btnWeek = document.getElementById('btnWeek')
    const btnJourney = document.getElementById('btnJourney')
    const shareBtn = document.getElementById('shareBtn')
    const legendRow = document.getElementById('legendRow')
    const headerAvatar = document.getElementById('headerAvatar')
    const headerName = document.getElementById('headerName')
    const headerEmail = document.getElementById('headerEmail')
    const profileBtn = document.getElementById('profileBtn')

    function setSaveButtonState(state) {
      if (!saveTodayBtn) return;

      saveTodayBtn.classList.remove(
        'opacity-60',
        'cursor-wait',
        'bg-green-100',
        'text-green-700',
        'border-green-500'
      );
      saveTodayBtn.disabled = false;

      if (state === 'saving') {
        saveTodayBtn.textContent = 'Saving…';
        saveTodayBtn.disabled = true;
        saveTodayBtn.classList.add('opacity-60', 'cursor-wait');
      } else if (state === 'saved') {
        saveTodayBtn.textContent = 'Saved ✓';
        saveTodayBtn.disabled = true;
        saveTodayBtn.classList.add('bg-green-100', 'text-green-700', 'border-green-500');
      } else {
        saveTodayBtn.textContent = 'Save';
      }
    }

    let chartInstance = null
    let currentMode = 'november' // 'november' | 'week' | 'journey'

    function fmtExact(n){ return String(Number(n)) }
    function curDateISO(){ return new Date().toISOString().slice(0,10) }
    dateField.value = curDateISO()

    // target line plugin
    const targetLinePlugin = {
      id: 'targetLinePlugin',
      afterDraw: (chart) => {
        const ctx = chart.ctx
        const yScale = chart.scales.y
        if (!yScale) return
        const yValue = TARGET_WORDS
        let yPixel = yScale.getPixelForValue(yValue)
        const top = yScale.top, bottom = yScale.bottom
        if (yPixel < top) yPixel = top
        if (yPixel > bottom) yPixel = bottom

        ctx.save()
        ctx.beginPath()
        ctx.setLineDash([6,4])
        ctx.strokeStyle = 'rgba(220,38,38,0.9)'
        ctx.lineWidth = 1.2
        ctx.moveTo(chart.chartArea.left, yPixel)
        ctx.lineTo(chart.chartArea.right, yPixel)
        ctx.stroke()
        ctx.setLineDash([])

        const label = `Target — ${TARGET_WORDS}`
        ctx.font = '12px Inconsolata, monospace'
        const padding = 6
        const textW = ctx.measureText(label).width
        const boxW = textW + padding*2
        const boxH = 20
        const boxX = chart.chartArea.right - boxW - 8
        const boxY = yPixel - boxH/2

        ctx.fillStyle = 'rgba(220,38,38,0.95)'
        ctx.fillRect(boxX, boxY, boxW, boxH)
        ctx.fillStyle = 'white'
        ctx.textBaseline = 'middle'
        ctx.fillText(label, boxX + padding, boxY + boxH/2)
        ctx.restore()
      }
    }

    function computeColors(values) {
      const maxVal = Math.max(...values)
      return values.map(v => {
        if (!v || v === 0) return COLOR_ZERO
        if (v === maxVal && maxVal > 0) return COLOR_HIGHEST
        if (v > TARGET_WORDS) return COLOR_OVER
        return COLOR_NORMAL
      })
    }

    function renderLegendRow() {
      legendRow.innerHTML = ''
      const items = [
        { label: 'Written (normal)', color: COLOR_NORMAL },
        { label: 'No words', color: COLOR_ZERO, zero:true },
        { label: `Over target (${TARGET_WORDS}+)`, color: COLOR_OVER },
        { label: 'Highest', color: COLOR_HIGHEST }
      ]
      items.forEach(it => {
        const wrap = document.createElement('div'); wrap.className = 'flex items-center gap-2 text-xs muted'
        const box = document.createElement('span'); box.className = 'legend-box'
        if (it.zero) box.classList.add('zero-box')
        box.style.background = it.zero ? COLOR_ZERO : it.color
        box.style.border = it.zero ? '1px dashed rgba(31,41,51,0.12)' : '1px solid rgba(0,0,0,0.06)'
        wrap.appendChild(box)
        const txt = document.createElement('div'); txt.textContent = it.label
        wrap.appendChild(txt)
        legendRow.appendChild(wrap)
      })
    }

    function renderHistogram(labels, values) {
      const maxVal = Math.max(...values)
      const suggested = (maxVal <= TARGET_WORDS) ? TARGET_WORDS : Math.ceil(maxVal * 1.2 / 100) * 100
      const colors = computeColors(values)
      if (chartInstance) { chartInstance.destroy(); chartInstance = null }

      const barThickness = Math.max(14, Math.floor((mainCanvas.clientWidth / Math.max(1, labels.length)) * 0.8))

      chartInstance = new Chart(mainCanvas.getContext('2d'), {
        type: 'bar',
        data: {
          labels,
          datasets: [{
            label: 'Words',
            data: values,
            backgroundColor: colors,
            borderRadius: {topLeft:6, topRight:6, bottomLeft:0, bottomRight:0},
            borderSkipped: 'bottom',
            barThickness
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: { grid: { display: false }, ticks: { maxRotation: 0, autoSkip: true, maxTicksLimit: 12, color: 'rgba(31,41,51,0.8)' } },
            y: { beginAtZero: true, suggestedMax: suggested, grid: { color: 'rgba(31,41,51,0.06)' }, ticks: { callback: v => v >= 1000 ? (v/1000)+'k' : v } }
          },
          plugins: {
            legend: { display: false },
            tooltip: { callbacks: { label: ctx => `${ctx.raw.toLocaleString()} words` } }
          },
          onClick: (evt) => {
            const elements = chartInstance.getElementsAtEventForMode(evt.native, 'nearest', { intersect: true }, true)
            if (elements && elements.length) {
              const el = elements[0]; const idx = el.index
              const val = chartInstance.data.datasets[0].data[idx] || 0
              showFloatingValue(evt.native.clientX, evt.native.clientY, `${val.toLocaleString()} words`)
            }
          }
        },
        plugins: [targetLinePlugin]
      })

      renderLegendRow()
    }

    function renderJourney(labels, values) {
      const cum = []; let s = 0
      values.forEach(v => { s += (v || 0); cum.push(s) })
      const maxVal = Math.max(...cum)
      const suggestedMax = Math.max(5000, Math.ceil(maxVal / 100) * 100)
      if (chartInstance) { chartInstance.destroy(); chartInstance = null }

      chartInstance = new Chart(mainCanvas.getContext('2d'), {
        type: 'line',
        data: {
          labels,
          datasets: [{
            label: 'Cumulative words',
            data: cum,
            borderColor: COLOR_NORMAL,
            backgroundColor: 'rgba(31,41,51,0.06)',
            fill: true,
            tension: 0.25,
            pointRadius: 3,
            pointBackgroundColor: COLOR_NORMAL,
            borderWidth: 2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: { grid: { display: false }, ticks: { autoSkip: true } },
            y: { beginAtZero: true, suggestedMax: suggestedMax, grid: { color: 'rgba(31,41,51,0.06)' }, ticks: { callback: v => v >= 1000 ? (v/1000)+'k' : v } }
          },
          plugins: {
            legend: { display: false },
            tooltip: { callbacks: { label: ctx => `${ctx.raw.toLocaleString()} words` } }
          },
          onClick: (evt) => {
            const elements = chartInstance.getElementsAtEventForMode(evt.native, 'nearest', { intersect: true }, true)
            if (elements && elements.length) {
              const el = elements[0]; const idx = el.index
              const val = chartInstance.data.datasets[0].data[idx] || 0
              showFloatingValue(evt.native.clientX, evt.native.clientY, `${val.toLocaleString()} words`)
            }
          }
        }
      })

      renderLegendRow()
    }

    let floatingTooltipTimeout = null
    function showFloatingValue(clientX, clientY, text) {
      const existing = document.querySelector('.bar-value-tooltip')
      if (existing) existing.remove()
      if (floatingTooltipTimeout) clearTimeout(floatingTooltipTimeout)
      const div = document.createElement('div'); div.className = 'bar-value-tooltip'; div.textContent = text
      document.body.appendChild(div)
      const left = clientX; const top = clientY - 12
      div.style.left = `${left}px`; div.style.top = `${top}px`
      floatingTooltipTimeout = setTimeout(()=> { div.remove(); floatingTooltipTimeout = null }, 2500)
    }

    async function fetchDailyCountsBetween(startISO, endISO) {
      const { data, error } = await supabase
        .from('daily_wordcounts')
        .select('day, words, time_spent_minutes')
        .gte('day', startISO)
        .lte('day', endISO)
      if (error) { console.warn('fetchDailyCountsBetween error', error); return [] }
      return data
    }

    function dummyDailyValues(length) {
      const base = 1200
      const arr = []
      for (let i=0;i<length;i++) {
        const ramp = Math.round(base + (i * 60) + (Math.random() * 1400))
        arr.push(ramp)
      }
      return arr
    }

    async function loadRangeData(mode = 'november') {
      const now = new Date();

      let labels = [];
      let dateKeys = [];
      let startISO, endISO;

      if (mode === 'november') {
        const year = now.getFullYear();
        for (let d = 1; d <= 30; d++) {
          const dt = new Date(year, 10, d);
          const iso = dt.toISOString().slice(0, 10);
          dateKeys.push(iso);
          labels.push(`Nov ${d}`);
        }
        startISO = dateKeys[0];
        endISO = dateKeys[dateKeys.length - 1];
      } else if (mode === 'week') {
        const day = now.getDay();
        const sunday = new Date(now);
        sunday.setDate(now.getDate() - day);
        for (let i = 0; i < 7; i++) {
          const d = new Date(sunday);
          d.setDate(sunday.getDate() + i);
          const iso = d.toISOString().slice(0, 10);
          dateKeys.push(iso);
          labels.push(
            new Intl.DateTimeFormat('en', { weekday: 'short', day: 'numeric' }).format(d)
          );
        }
        startISO = dateKeys[0];
        endISO = dateKeys[dateKeys.length - 1];
      } else if (mode === 'journey') {
        const num = 30;
        const end = new Date(now);
        const tmp = [];
        for (let i = num - 1; i >= 0; i--) {
          const d = new Date(end);
          d.setDate(end.getDate() - i);
          const iso = d.toISOString().slice(0, 10);
          tmp.push({ iso, d });
        }
        dateKeys = tmp.map(o => o.iso);
        labels = tmp.map(o =>
          new Intl.DateTimeFormat('en', { month: 'short', day: 'numeric' }).format(o.d)
        );
        startISO = dateKeys[0];
        endISO = dateKeys[dateKeys.length - 1];
      } else {
        return { labels: [], values: [], times: [], dateKeys: [] };
      }

      const rows = await fetchDailyCountsBetween(startISO, endISO);

      const wordMap = {};
      const timeMap = {};

      if (rows && rows.length) {
        rows.forEach(r => {
          const dStr = typeof r.day === 'string'
            ? r.day.slice(0, 10)
            : new Date(r.day).toISOString().slice(0, 10);

          const w = Number(r.words) || 0;
          const t = Number(r.time_spent_minutes) || 0;

          wordMap[dStr] = (wordMap[dStr] || 0) + w;
          timeMap[dStr] = (timeMap[dStr] || 0) + t;
        });
      }

      let values = dateKeys.map(k => wordMap[k] || 0);
      let times  = dateKeys.map(k => timeMap[k] || 0);

      if (values.every(v => v === 0)) {
        values = dummyDailyValues(dateKeys.length);
        times  = new Array(dateKeys.length).fill(0);
      }

      return { labels, values, times, dateKeys };
    }

    async function loadDataAndRender(mode = 'november') {
      currentMode = mode;
      try {
        const { labels, values, times, dateKeys } = await loadRangeData(mode);

        const safeTimes = Array.isArray(times) ? times.map(t => Number(t) || 0) : [];
        const todayISO  = curDateISO();

        const elapsedDays = Array.isArray(dateKeys)
          ? dateKeys.filter(d => d <= todayISO).length
          : 0;

        const denomDays = Math.max(1, elapsedDays);

        const totalWords = values.reduce((a, b) => a + (b || 0), 0);
        const avgWords   = Math.round(totalWords / denomDays);

        const totalTime  = safeTimes.reduce((a, b) => a + b, 0);
        const avgTime    = Math.round(totalTime / denomDays);

        totalWordsEl.textContent = fmtExact(totalWords);
        avgDailyEl.textContent   = fmtExact(avgWords);
        totalTimeEl.textContent  = `${totalTime} min`;
        avgTimeEl.textContent    = `${avgTime} min`;

        if (mode === 'journey') {
          renderJourney(labels, values);
        } else {
          renderHistogram(labels, values);
        }
      } catch (err) {
        console.error('loadDataAndRender error', err);
      }
    }

    // ---------- USERS / PROFILE ----------
    async function ensureUserRow(session) {
      const authUser = session.user

      const { data: existing, error: fetchErr } = await supabase
        .from('users')
        .select('id, email, display_name, avatar_url, daily_target_words')
        .eq('auth_user_id', authUser.id)
        .maybeSingle()

      if (fetchErr) {
        console.error('ensureUserRow fetch error:', fetchErr.message || fetchErr)
        return null
      }

      if (existing) return existing

      const payload = {
        auth_user_id: authUser.id,
        email: authUser.email,
        display_name: authUser.user_metadata?.full_name || authUser.email,
        avatar_url: authUser.user_metadata?.avatar_url || null,
        daily_target_words: 1667
      }

      const { data: inserted, error: insertErr } = await supabase
        .from('users')
        .insert(payload)
        .select()
        .single()

      if (insertErr) {
        console.error('ensureUserRow insert error:', insertErr.message || insertErr)
        return null
      }

      return inserted
    }

    async function initProfileArea() {
      const { data: { session } } = await supabase.auth.getSession()

      if (!session || !session.user) {
        headerAvatar.src = 'https://placehold.co/200x200?text=G'
        headerName.textContent = 'Sign in'
        headerEmail.textContent = ''
        profileBtn.onclick = () => {
          supabase.auth.signInWithOAuth({
            provider: 'google',
            options: { redirectTo: window.location.origin + '/dashboard.html' }
          })
        }
        return
      }

      const userRow = await ensureUserRow(session)
      if (!userRow) {
        headerName.textContent = 'Preparing account'
        headerAvatar.src = 'https://placehold.co/200x200?text=U'
        return
      }

      try {
        const { data: userSettings, error: settingsErr } = await supabase
          .from('users')
          .select('daily_target_words')
          .eq('id', userRow.id)
          .single()

        if (!settingsErr && userSettings && typeof userSettings.daily_target_words === 'number') {
          if (userSettings.daily_target_words > 0) {
            TARGET_WORDS = userSettings.daily_target_words
          }
        }
      } catch (e) {
        console.warn('Could not load daily target, falling back to default 1667', e)
      }

      headerAvatar.src = userRow.avatar_url || 'https://placehold.co/200x200?text=U'
      headerName.textContent = userRow.display_name || userRow.email
      headerEmail.textContent = userRow.email || ''

      profileBtn.onclick = () => {
        window.location.href = `${window.location.origin}/profile.html`
      }
    }

    // ---------- UPSERT ----------
    async function upsertToday(words, timeSpent, dayISO) {
      setSaveButtonState('saving');
      saveMsg.textContent = '';

      const { data: { session } } = await supabase.auth.getSession();
      if (!session || !session.user) {
        saveMsg.textContent = 'Sign in first';
        setSaveButtonState('idle');
        return;
      }

      const { data: userRow, error: userErr } = await supabase
        .from('users')
        .select('id')
        .eq('auth_user_id', session.user.id)
        .single();

      if (userErr || !userRow) {
        console.error('User row fetch error', userErr);
        saveMsg.textContent = 'Account not ready';
        setSaveButtonState('idle');
        return;
      }

      try {
        const { error: sessionErr } = await supabase
          .from('sessions')
          .insert({
            user_id: userRow.id,
            day: dayISO,
            words: words,
            time_spent_minutes: timeSpent,
            source: 'manual_log'
          });

        if (sessionErr) throw sessionErr;

        const { data: aggRows, error: aggErr } = await supabase
          .from('sessions')
          .select('words, time_spent_minutes')
          .eq('user_id', userRow.id)
          .eq('day', dayISO);

        if (aggErr) throw aggErr;

        let totalWords = 0;
        let totalMinutes = 0;

        (aggRows || []).forEach(r => {
          totalWords += Number(r.words) || 0;
          totalMinutes += Number(r.time_spent_minutes) || 0;
        });

        const { error: upsertErr } = await supabase
          .from('daily_wordcounts')
          .upsert({
            user_id: userRow.id,
            day: dayISO,
            words: totalWords,
            time_spent_minutes: totalMinutes,
            updated_at: new Date().toISOString()
          }, {
            onConflict: 'user_id,day'
          });

        if (upsertErr) throw upsertErr;

        await loadDataAndRender(currentMode);

        saveMsg.textContent = 'Saved!';
        setSaveButtonState('saved');
        setTimeout(() => {
          setSaveButtonState('idle');
        }, 2000);
      } catch (err) {
        console.error(err);
        saveMsg.textContent = 'Save failed';
        setSaveButtonState('idle');
      }
    }

    saveTodayBtn.onclick = async () => {
      const dayISO = dateField.value || curDateISO();
      const val = parseInt(todayInput.value || '0', 10);
      const t = parseInt(timeInput.value || '0', 10) || 0;

      if (isNaN(val) || val < 0) {
        saveMsg.textContent = 'Enter a valid word count';
        return;
      }

      await upsertToday(val, t, dayISO);
    }

    function setActiveFilter(mode) {
      document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'))
      if (mode === 'november') btnNov.classList.add('active')
      else if (mode === 'week') btnWeek.classList.add('active')
      else if (mode === 'journey') btnJourney.classList.add('active')
    }
    btnNov.addEventListener('click', ()=> { setActiveFilter('november'); loadDataAndRender('november') })
    btnWeek.addEventListener('click', ()=> { setActiveFilter('week'); loadDataAndRender('week') })
    btnJourney.addEventListener('click', ()=> { setActiveFilter('journey'); loadDataAndRender('journey') })

    shareBtn.addEventListener('click', (e) => {
      e.preventDefault();
      alert('Sharing coming soon.');
    });

    // --- AUTH GUARD: exchange code if present, then wait for session ---
    async function waitForSessionOrRedirect() {
      const indexUrl = `${window.location.origin}/index.html`;
      const url = new URL(window.location.href);
      const code = url.searchParams.get('code');
      const errorParam = url.searchParams.get('error');
      const errorDesc = url.searchParams.get('error_description');

      if (errorParam) {
        console.error('[PZ] OAuth error in URL:', errorParam, errorDesc || '');
        window.location.href = indexUrl;
        return null;
      }

      let session = null;

      if (code) {
        console.log('[PZ] code param detected, attempting exchangeCodeForSession');
        try {
          const { data, error } = await supabase.auth.exchangeCodeForSession(window.location.href);
          if (error) {
            console.error('[PZ] exchangeCodeForSession error:', error);
          } else {
            session = data?.session || null;
            console.log('[PZ] exchangeCodeForSession session:', !!session);
          }
        } catch (e) {
          console.error('[PZ] exchangeCodeForSession threw:', e);
        }
      }

      // If we still don't have a session, poll getSession a few times
      if (!session) {
        for (let i = 0; i < 10; i++) {
          try {
            const { data, error } = await supabase.auth.getSession();
            if (error) {
              console.error('[PZ] getSession error (attempt', i+1, '):', error);
            }
            if (data?.session) {
              session = data.session;
              console.log('[PZ] getSession success on attempt', i+1);
              break;
            }
          } catch (e) {
            console.error('[PZ] getSession threw (attempt', i+1, '):', e);
          }
          await new Promise(res => setTimeout(res, 300));
        }
      }

      if (!session) {
        console.warn('[PZ] No session after exchange+polling, redirecting to index');
        window.location.href = indexUrl;
        return null;
      }

      // Clean the URL (drop code/error params)
      try {
        history.replaceState({}, document.title, window.location.pathname);
      } catch (_) {}

      return session;
    }

    // boot
    document.addEventListener('DOMContentLoaded', async () => {
      const session = await waitForSessionOrRedirect();
      if (!session) return;

      await initProfileArea();
      setActiveFilter(currentMode);
      await loadDataAndRender(currentMode);

      window.addEventListener('resize', () => {
        if (chartInstance) chartInstance.update();
      });
    });
  </script>
</body>
</html>
